/**
 * 44th RAR Training Calendar System - AUTOMATED Backend
 * Complete rebuilt script with all fixes including Discord notifications
 */

// Configuration
const CONFIG = {
  CALENDAR_ID: PropertiesService.getScriptProperties().getProperty('CALENDAR_ID'),
  MAIN_SHEET_ID: PropertiesService.getScriptProperties().getProperty('MAIN_SHEET_ID'),
  ACCESS_SHEET_ID: PropertiesService.getScriptProperties().getProperty('ACCESS_SHEET_ID'),
  DISCORD_WEBHOOK: PropertiesService.getScriptProperties().getProperty('DISCORD_WEBHOOK'),
  BUFFER_MINUTES: 15,
  TIMEZONE: 'Europe/London'
};

// Main GET entry point
function doGet(e) {
  // Handle checkAccess action
  if (e.parameter.action === 'checkAccess') {
    const email = e.parameter.email.toLowerCase();
    
    let debugInfo = {
      emailSearched: email,
      sheetsChecked: [],
      error: null
    };
    
    try {
      const mainSheet = SpreadsheetApp.openById(CONFIG.MAIN_SHEET_ID);
      
      // Check D&E Access sheet
      const deAccessTab = mainSheet.getSheetByName('D&E Access');
      if (deAccessTab) {
        const deAccessData = deAccessTab.getDataRange().getValues();
        debugInfo.sheetsChecked.push({
          name: 'D&E Access',
          rows: deAccessData.length,
          firstRowEmails: deAccessData.slice(1, 4).map(row => row[2])
        });
        
        for (let i = 1; i < deAccessData.length; i++) {
          if (deAccessData[i][2] && deAccessData[i][2].toLowerCase() === email) {
            return ContentService.createTextOutput(JSON.stringify({
              authorized: true,
              role: 'd&e',
              name: deAccessData[i][0] || email.split('@')[0]
            })).setMimeType(ContentService.MimeType.JSON);
          }
        }
      }
      
      // Check Trainer Access sheet
      const trainerAccessTab = mainSheet.getSheetByName('Trainer Access');
      if (trainerAccessTab) {
        const trainerAccessData = trainerAccessTab.getDataRange().getValues();
        debugInfo.sheetsChecked.push({
          name: 'Trainer Access',
          rows: trainerAccessData.length,
          firstRowEmails: trainerAccessData.slice(1, 4).map(row => row[2])
        });
        
        for (let i = 1; i < trainerAccessData.length; i++) {
          if (trainerAccessData[i][2] && trainerAccessData[i][2].toLowerCase() === email) {
            return ContentService.createTextOutput(JSON.stringify({
              authorized: true,
              role: 'trainer',
              name: trainerAccessData[i][0] || email.split('@')[0]
            })).setMimeType(ContentService.MimeType.JSON);
          }
        }
      }
    } catch (error) {
      debugInfo.error = error.toString();
    }
    
    return ContentService.createTextOutput(JSON.stringify({
      authorized: false,
      debug: debugInfo
    })).setMimeType(ContentService.MimeType.JSON);
  }
  
  // Handle other public actions
  if (e.parameter.action) {
    const action = e.parameter.action;
    
    // Build data object from GET parameters
    const data = {
      category: e.parameter.category || '',
      training: e.parameter.training || '',
      userEmail: e.parameter.userEmail || '',
      date: e.parameter.date || '',
      time: e.parameter.time || '',
      duration: e.parameter.duration || '',
      server: e.parameter.server || '',
      serverOther: e.parameter.serverOther || '',
      instructor: e.parameter.instructor || '',
      instructorOther: e.parameter.instructorOther || '',
      zeusRequired: e.parameter.zeusRequired || '',
      gynRequired: e.parameter.gynRequired || '',
      requesterName: e.parameter.requesterName || '',
      requesterDiscord: e.parameter.requesterDiscord || '',
      notes: e.parameter.notes || '',
      eventId: e.parameter.eventId || ''
    };
    
    // Handle each action
    switch(action) {
      case 'getInstructors':
        return ContentService.createTextOutput(
          JSON.stringify(handleGetInstructors(data))
        ).setMimeType(ContentService.MimeType.JSON);
        
      case 'getSchedule':
        return ContentService.createTextOutput(
          JSON.stringify(handleGetSchedule(data))
        ).setMimeType(ContentService.MimeType.JSON);
        
      case 'checkAvailability':
        return ContentService.createTextOutput(
          JSON.stringify(handleCheckAvailability(data))
        ).setMimeType(ContentService.MimeType.JSON);
        
      case 'submitRequest':
        return ContentService.createTextOutput(
          JSON.stringify(handleTrainingRequest(data))
        ).setMimeType(ContentService.MimeType.JSON);
        
      case 'getStats':
        return ContentService.createTextOutput(
          JSON.stringify(handleGetStats(data))
        ).setMimeType(ContentService.MimeType.JSON);
        
      case 'getBookings':
       return ContentService.createTextOutput(
        JSON.stringify(handleGetBookings(data))
       ).setMimeType(ContentService.MimeType.JSON);

      case 'createBooking':
        return ContentService.createTextOutput(
          JSON.stringify(handleCreateBooking(data))
        ).setMimeType(ContentService.MimeType.JSON);
        
      case 'deleteBooking':
        return ContentService.createTextOutput(
          JSON.stringify(handleDeleteBooking(data))
        ).setMimeType(ContentService.MimeType.JSON);
        
      default:
        return ContentService.createTextOutput(JSON.stringify({
          success: false,
          message: 'Unknown action: ' + action
        })).setMimeType(ContentService.MimeType.JSON);
    }
  }
  
  // Default response
  return ContentService.createTextOutput(JSON.stringify({
    status: 'Active',
    message: 'Training Calendar API'
  })).setMimeType(ContentService.MimeType.JSON);
}

// Main POST entry point
function doPost(e) {
  try {
    const data = JSON.parse(e.postData.contents);
    const action = data.action;
    
    // For now, redirect all to GET handlers
    switch(action) {
      case 'submitRequest':
        return ContentService.createTextOutput(
          JSON.stringify(handleTrainingRequest(data))
        ).setMimeType(ContentService.MimeType.JSON);
        
      case 'createBooking':
        return ContentService.createTextOutput(
          JSON.stringify(handleCreateBooking(data))
        ).setMimeType(ContentService.MimeType.JSON);
        
      default:
        return createResponse(false, 'Invalid action');
    }
    
  } catch (error) {
    return createResponse(false, error.toString());
  }
}

// Create response helper
function createResponse(success, message, data = null) {
  return {
    success: success,
    message: message,
    data: data,
    timestamp: new Date().toISOString()
  };
}

// Get instructors for a specific training
function handleGetInstructors(data) {
  try {
    const sheet = SpreadsheetApp.openById(CONFIG.MAIN_SHEET_ID)
      .getSheetByName('Instructors');
    
    if (!sheet) {
      return createResponse(false, 'Instructors sheet not found');
    }
    
    const instructors = sheet.getDataRange().getValues();
    const filtered = [];
    
    // Map training to instructor lookup
    const trainingType = getInstructorCategory(data.category, data.training);
    
    // Start from row 1 to skip headers
    for (let i = 1; i < instructors.length; i++) {
      if (instructors[i][0] === trainingType) {
        filtered.push({
          name: instructors[i][1],
          discord: instructors[i][2]
        });
      }
    }
    
    return createResponse(true, 'Instructors retrieved', {
      instructors: filtered,
      trainingType: trainingType
    });
    
  } catch (error) {
    return createResponse(false, error.toString());
  }
}

// Map training to instructor category
function getInstructorCategory(category, training) {
  // Direct mappings to Column A values in Instructors sheet
  const instructorTypes = {
    'GYN': 'GYN',
    'LAT': 'LAT',
    'HAT': 'HAT',
    'Advanced AT Training': 'Advanced AT Training',
    'Engineer': 'Engineer',
    'Grenadier': 'Grenadier',
    'Logistics': 'Logistics',
    'MG/AR': 'MG/AR',
    'Marksman': 'Marksman',
    'Medic': 'Medic',
    'Mortar': 'Mortar',
    'TOW': 'TOW',
    'Fibua Tier 1': 'Fibua Tier 1',
    'Section Battle Drills': 'Section Battle Drills',
    'Squad Leading Tier 1': 'Squad Leading',
    'Squad Leading Tier 2': 'Squad Leading',
    'Squad Leading Tier 3': 'Squad Leading'
  };
  
  // Category-based mappings
  const categoryMappings = {
    'mbt': 'MBT - Trooper',
    'ifv': 'IFV',
    'mechInf': 'Mech Inf',
    'pilot': 'Pilot',
    'motorInf': 'Motor Inf',
    'infantry': 'Infantry'
  };
  
  // First check specific training
  if (instructorTypes[training]) {
    return instructorTypes[training];
  }
  
  // Then check category
  if (categoryMappings[category.toLowerCase()]) {
    return categoryMappings[category.toLowerCase()];
  }
  
  // Default fallback
  return training;
}

// Check availability
function handleCheckAvailability(data) {
  try {
    const calendar = CalendarApp.getCalendarById(CONFIG.CALENDAR_ID);
    const startTime = new Date(`${data.date}T${data.time}:00`);
    const endTime = new Date(startTime.getTime() + (parseInt(data.duration) + CONFIG.BUFFER_MINUTES) * 60000);
    
    const events = calendar.getEvents(startTime, endTime);
    
    if (events.length > 0) {
      const conflicts = events.map(event => ({
        title: event.getTitle(),
        start: event.getStartTime().toISOString(),
        end: event.getEndTime().toISOString()
      }));
      
      return createResponse(false, 'Time slot unavailable', {
        available: false,
        conflicts: conflicts
      });
    }
    
    return createResponse(true, 'Time slot available', {
      available: true,
      message: 'This slot is free and can be booked instantly'
    });
    
  } catch (error) {
    return createResponse(false, error.toString());
  }
}

// Get schedule
function handleGetSchedule(data) {
  try {
    const calendar = CalendarApp.getCalendarById(CONFIG.CALENDAR_ID);
    const startDate = new Date(data.startDate || new Date());
    const endDate = new Date(data.endDate || new Date(startDate.getTime() + 30 * 24 * 60 * 60 * 1000));
    
    const events = calendar.getEvents(startDate, endDate);
    
    const schedule = events.map(event => {
      const title = event.getTitle();
      const parts = title.split(' - ');
      
      return {
        id: event.getId(),
        title: title,
        training: parts[0] || 'Training',
        server: parts[1] || 'TBD',
        instructor: parts[2] || 'TBD',
        start: event.getStartTime().toISOString(),
        end: event.getEndTime().toISOString(),
        description: event.getDescription()
      };
    });
    
    return createResponse(true, 'Schedule retrieved', {
      events: schedule,
      count: schedule.length
    });
    
  } catch (error) {
    return createResponse(false, error.toString());
  }
}

// Submit training request
function handleTrainingRequest(data) {
  try {
    const sheet = SpreadsheetApp.openById(CONFIG.MAIN_SHEET_ID)
      .getSheetByName('Requests');
    
    if (!sheet) {
      throw new Error('Requests sheet not found');
    }
    
    sheet.appendRow([
      new Date(),
      data.requesterName || 'Anonymous',
      data.category || '',
      data.training || '',
      data.notes || '',
      'Pending',
      '', // Assigned Instructor
      '', // Approved By
      data.zeusRequired || 'No',
      data.gynRequired || 'No'
    ]);
    
    // Send Discord notification for training request
    sendDiscordNotification({
      embeds: [{
        title: "🎯 New Training Request",
        color: 0xF4B643,
        fields: [
          {
            name: "Requester",
            value: data.requesterName || 'Anonymous',
            inline: true
          },
          {
            name: "Category",
            value: data.category || 'Not specified',
            inline: true
          },
          {
            name: "Training",
            value: data.training || 'Not specified',
            inline: true
          },
          {
            name: "Zeus Required",
            value: data.zeusRequired || 'No',
            inline: true
          },
          {
            name: "GYN Required",
            value: data.gynRequired || 'No',
            inline: true
          },
          {
            name: "Notes",
            value: data.notes || 'None provided',
            inline: false
          }
        ],
        timestamp: new Date().toISOString(),
        footer: {
          text: "44th SMS - Training Request System"
        }
      }]
    });
    
    return createResponse(true, 'Request logged for analytics', {
      message: 'Your training request has been recorded'
    });
    
  } catch (error) {
    return createResponse(false, error.toString());
  }
}

// Create booking
function handleCreateBooking(data) {
  try {
    // Check if user is authorized
    if (!data.userEmail) {
      return createResponse(false, 'Not authorized to create bookings');
    }
    
    // Check availability first
    const availCheck = handleCheckAvailability(data);
    if (!availCheck.success || !availCheck.data.available) {
      return createResponse(false, 'Time slot not available', availCheck.data);
    }
    
    // Create calendar event
    const calendar = CalendarApp.getCalendarById(CONFIG.CALENDAR_ID);
    const startTime = new Date(`${data.date}T${data.time}:00`);
    const endTime = new Date(startTime.getTime() + parseInt(data.duration) * 60000);
    
    const server = data.server === 'Other' ? data.serverOther : data.server;
    const instructor = data.instructor === 'Other' ? data.instructorOther : data.instructor;
    
    const event = calendar.createEvent(
      `${data.training} - ${server} - ${instructor}`,
      startTime,
      endTime,
      {
        description: `Training: ${data.category} - ${data.training}\n` +
                    `Instructor: ${instructor}\n` +
                    `Server: ${server}\n` +
                    `Zeus Required: ${data.zeusRequired || 'No'}\n` +
                    `GYN Required: ${data.gynRequired || 'No'}\n` +
                    `Duration: ${data.duration} minutes\n` +
                    `Booked by: ${data.userEmail}\n` +
                    `Booked at: ${new Date().toISOString()}`
      }
    );
    
    // Log to Bookings sheet
    const sheet = SpreadsheetApp.openById(CONFIG.MAIN_SHEET_ID)
      .getSheetByName('Bookings');
    
    if (sheet) {
      sheet.appendRow([
        new Date(),
        data.userEmail,
        data.category,
        data.training,
        data.duration,
        data.zeusRequired || 'No',
        data.gynRequired || 'No',
        instructor,
        server,
        data.date,
        data.time,
        'Scheduled',
        event.getId(),
        data.userEmail
      ]);
    }
    
    // Send Discord notification for booking confirmation
    const formattedDate = new Date(`${data.date}T${data.time}:00`).toLocaleDateString('en-GB', {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      timeZone: 'Europe/London'
    });
    
    const formattedTime = new Date(`${data.date}T${data.time}:00`).toLocaleTimeString('en-GB', {
      hour: '2-digit',
      minute: '2-digit',
      timeZone: 'Europe/London'
    });
    
    sendDiscordNotification({
      embeds: [{
        title: "✅ Training Session Booked",
        color: 0x4CAF50,
        fields: [
          {
            name: "Training",
            value: `${data.category} - ${data.training}`,
            inline: false
          },
          {
            name: "Date & Time",
            value: `${formattedDate} at ${formattedTime} BST`,
            inline: true
          },
          {
            name: "Duration",
            value: `${data.duration} minutes`,
            inline: true
          },
          {
            name: "Server",
            value: server,
            inline: true
          },
          {
            name: "Instructor",
            value: instructor,
            inline: true
          },
          {
            name: "Zeus Required",
            value: data.zeusRequired || 'No',
            inline: true
          },
          {
            name: "GYN Required",
            value: data.gynRequired || 'No',
            inline: true
          },
          {
            name: "Booked By",
            value: data.userEmail.split('@')[0],
            inline: false
          }
        ],
        timestamp: new Date().toISOString(),
        footer: {
          text: "44th SMS - Booking Confirmation"
        }
      }]
    });
    
    return createResponse(true, 'Booking created successfully!', {
      eventId: event.getId(),
      message: 'Training session booked successfully'
    });
    
  } catch (error) {
    return createResponse(false, error.toString());
  }
}

// Get stats
function handleGetStats(data) {
  try {
    const bookingsSheet = SpreadsheetApp.openById(CONFIG.MAIN_SHEET_ID)
      .getSheetByName('Bookings');
    const requestsSheet = SpreadsheetApp.openById(CONFIG.MAIN_SHEET_ID)
      .getSheetByName('Requests');
    
    const bookings = bookingsSheet ? bookingsSheet.getDataRange().getValues().slice(1) : [];
    const requests = requestsSheet ? requestsSheet.getDataRange().getValues().slice(1) : [];
    
    return createResponse(true, 'Stats retrieved', {
      bookings: bookings,
      requests: requests,
      totalBookings: bookings.length,
      totalRequests: requests.length
    });
    
  } catch (error) {
    return createResponse(false, error.toString());
  }
}

// Send Discord notification
function sendDiscordNotification(payload) {
  try {
    if (!CONFIG.DISCORD_WEBHOOK) {
      console.log('Discord webhook URL not configured');
      return;
    }
    
    const response = UrlFetchApp.fetch(CONFIG.DISCORD_WEBHOOK, {
      method: 'POST',
      contentType: 'application/json',
      payload: JSON.stringify(payload)
    });
    
    console.log('Discord notification sent:', response.getResponseCode());
    
  } catch (error) {
    console.error('Discord notification error:', error);
  }
}

// Get bookings for management
function handleGetBookings(data) {
  try {
    const sheet = SpreadsheetApp.openById(CONFIG.MAIN_SHEET_ID)
      .getSheetByName('Bookings');
    
    if (!sheet) {
      return createResponse(false, 'Bookings sheet not found');
    }
    
    const bookings = sheet.getDataRange().getValues();
    const bookingData = [];
    
    for (let i = 1; i < bookings.length; i++) {
      const booking = bookings[i];
      bookingData.push({
        timestamp: booking[0],
        userEmail: booking[1],
        category: booking[2],
        training: booking[3],
        duration: booking[4],
        zeus: booking[5],
        gyn: booking[6] || 'No',
        instructor: booking[7],
        server: booking[8],
        date: booking[9],
        time: booking[10],
        status: booking[11],
        eventId: booking[12],
        bookedBy: booking[13]
      });
    }
    
    return createResponse(true, 'Bookings retrieved', {
      bookings: bookingData,
      count: bookingData.length
    });
    
  } catch (error) {
    return createResponse(false, error.toString());
  }
}

// Delete booking
function handleDeleteBooking(data) {
  try {
    if (!data.eventId) {
      return createResponse(false, 'Event ID required');
    }
    
    // Delete from calendar
    const calendar = CalendarApp.getCalendarById(CONFIG.CALENDAR_ID);
    const event = calendar.getEventById(data.eventId);
    
    if (event) {
      event.deleteEvent();
      
      // Update status in sheet
      const sheet = SpreadsheetApp.openById(CONFIG.MAIN_SHEET_ID)
        .getSheetByName('Bookings');
      
      if (sheet) {
        const bookings = sheet.getDataRange().getValues();
        
        for (let i = 1; i < bookings.length; i++) {
          if (bookings[i][12] === data.eventId) { // Event ID is column 12 (adjusted for new GYN column)
            sheet.getRange(i + 1, 12).setValue('Cancelled');
            break;
          }
        }
      }
      
      return createResponse(true, 'Booking deleted successfully');
    }
    
    return createResponse(false, 'Event not found');
    
  } catch (error) {
    return createResponse(false, error.toString());
  }
}
